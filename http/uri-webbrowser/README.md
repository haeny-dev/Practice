# URI 와 웹 브라우저 요청 흐름

## URI (Uniform Resource Identifier)

UR**I** ? UR**L** ? UR**N** ? 여러가지 표현들이 있는데 어떻게 뭐가 다른건지 구분하기 어렵다.

> URI 는 로케이터(Locator), 이름(Name) 또는 둘다 추가로 분류될 수있다.  
> [1.1.3. URI, URL, and URN](https://www.ietf.org/rfc/rfc3986.txt)

즉, URI 는 URL 과 URN 을 모두 포함하고 있는 개념인 셈이다.

URI 의 단어 뜻은   
- *Uniform: 리소스를 식별하는 통일된 방식*
  

- *Resource: 자원, URI 로 식별할 수 있는 모든 것 (제한 없음)*
  

- *Identifier: 다른 항목과 구분하는데 필요한 정보*

```text
* URL(Resource Locator):  foo://example.com:8042/over/there?name=ferret#nose
                           |           |              |          |        |
                        scheme     authority         path      query   fragment
                           |                          |
* URN(Resource Name):     urn:example:animal:ferret:nose
```

URL, URN 의 단어 뜻은

- *URL(Locator): 리소스가 있는 **위치**를 지정*
  

- *URN(Name): 리소스에 **이름**을 부여*

URN 의 경우 리소스의 위치는 변경될 수 있지만, 이름은 변하지 않는다 라는 특징을 갖고 있다.

URN 의 예를 보면, 어떤 책의 isbn URN 을 `urn:isbn:8960777331` 로 표현할 수 있다.

하지만, 예시와 마찬가지로 이름만으로 실제 리소스를 찾을 수 있는 방법은 보편화 되지 않았다.

그래서 대부분의 사람들이 말하는 URI 는 URL 을 말한다.

### URL
**URL 구성**

<span style="font-size: 16px;">scheme://[userinfo@]host[:port][/path][?query][#fragment]</span>

<span style="font-size: 16px;">예 ) https://www.google.com:443/search?q=hello&hl=ko </span>

**scheme**
- *주로 프로토콜로 사용*
- *프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 규약*
    - *예) http, https, ftp 등*

    
- *https 는 http 에 보안이 추가된 것을 말한다.(HTTP Secure)*

**userinfo**
- *URL 에 사용자정보를 포함해서 인증, 거의 사용하지 않는다.*

**host**
- *호스트명*
- *도메인명 또는 IP 주소를 직접 사용가능*

**port**
- *서버의 접속하고자 하는 프로세스의 포트*
- *일반적으로 생략하며, 생략시 http 는 80, https 는 443 이다.*

**path**
- *리소스 경로를 말하며 계층적 구조를 가지고 있다.*
- *예) /home/file1.jpg*

**query**
- *key, value 형태*
- *`?` 로 시작하고 `&` 로 추가 할 수 있다.*
- *query parameter, query string 등으로 불리며 웹 서버에 제공하는 문자 형태의 파라미터이다.*

**fragment**
- *html 내부 북마크 등에 사용하며, 서버에 전송하는 정보가 아니다.*

## 웹 브라우저 요청 흐름

웹 브라우저에 `https://www.google.com/search?q=hello&hl=ko` 라고 입력하면 어떤 일이 벌어지는 지 살펴보면,

1. *웹 브라우저가 HTTP 요청 메시지를 생성한다.*


2. *SOCKET 라이브러리를 통해 전달*

    2-1. *TCP/IP 연결 - IP, PORT*

    2-2. *데이터 전달*


3. *TCP/IP 패킷을 생성하고, HTTP 메시지를 포함시킨다.*


4. *패킷을 서버로 구글 서버로 전달한다.*


5. *클라이언트의 패킷을 전달받은 구글이 응답 패킷을 생성하여 전달*


6. *서버로부터 전달 받은 응답 패킷 내 데이터(HTML) 을 웹 브라우저가 렌더링 해준다.*

이러한 과정을 통해서 구글 검색 페이지를 웹 브라우저에서 볼 수 있는 것이다.

시작은 HTTP 요청에 의해 이루어진다.

### HTTP

HTTP 는 Hyper Text Transfer Protocol 을 말한다.

*HTTP 메시지에는 모든 것을 전송할 수 있다.*

- *HTML, TEXT*
- *이미지, 음성, 영상, 파일*
- *JSON, XML*
- *...*

거의 모든 형태의 데이터의 전송이 가능하다. 

보통 클라이언트 - 서버 구조를 띄고 있지만, 서버 - 서버 간에도 데이터를 주고 받을 때 대부분 HTTP 를 사용한다.

#### HTTP 역사

- *HTTP/0.9 (1991년): GET 메서드만 지원, HTTP 헤더 X*
- *HTTP/1.0 (1996년): 메서드, 헤더 추가*
- *HTTP/1.1 (1997년): 현재 가장 많이 사용하고 있는 버전*
    - *RFC2068(1997) > RFC2616(1999) > **RFC7230~7235 (2014)***
- *HTTP/2 (2015년): 성능 개선*
- *HTTP/3 진행 중: TCP 대신에 UDP 사용하여 성능 개선*

#### 기반 프로토콜
- *TCP: HTTP/1.1, HTTP/2*


- *UDP: HTTP/3*


- *현재 HTTP/1.1 주로 사용하고 있고, HTTP/2, HTTP/3 도 점점 증가*

#### HTTP 특징

HTTP 특징을 살펴보면,

**클라이언트 서버 구조**를 띄고 있다.

- *Request, Response 구조*
  

- *클라이언트는 서버에 요청을 보내고, 응답을 대기하고,*
  

- *서버가 요청에 대한 결과를 만들어서 응답을 보낸다.*

그 다음 특징으로는,

**무상태 프로토콜** 이라는 점이다. 스테이스리스(Stateless) 라고도 표현하는데,

- *서버가 클라이언트의 상태를 보존하지 않는다*


- *장점으로는 서버 확장성이 높다*


- *단점으로는 클라이언트가 추가 데이터 전송 시 추가 데이터만 전송이 불가능 하다*

상태 유지(Stateful) 과 무상태(Stateless) 의 차이를 알아보자.

한 고객이 노트북을 구매하려는 상황을 예로 들어보자.

```text
<일반적인 점원이 한 명인 경우>

고객: 이 노트북 얼마인가요?
점원: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원: 200만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠어요?

고객: 신용카드로 구매하겠습니다.
점원: 200만원 결제 완료되었습니다.

<점원이 중간에 계속 바뀌는 경우>

고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원B: ?? 어떤 제품을 2개 구매하시겠어요??

고객: 신용카드로 구매하겠습니다.
점원C: ??? 어떤 제품을 몇 개 신용카드로 구매하시겠다는건가요??
```

위의 예를 봤을 때, 

일반적인 점원이 한 명인 경우에는 고객이 사려는 것이 노트북이고 노트북을 2개 산다는 것을 알기 때문에 신용카드 결제까지 자연스럽게 이어질 수 있었다.

하지만 점원이 중간에 바뀌는 경우에는 고객이 2개를 구매한다고 하거나 신용카드로 구매한다고 하였을 때, 

어떤 제품을 사려는지, 어떤 제품을 2개 사려는지에 대해 알지 못하기 때문에 고객이 요구하는 것을 제대로 이행하지 못했다. 

이와 같이 일반적인 점원이 한 명이 고객이 새로운 정보를 전달해도 이전의 정보를 기억하고 있는 것을 **Stateful** 하다고 한다.

그리고 점원이 중간에 바뀌어서 이전의 정보를 기억하고 있지 않는 것을 **Stateless** 라고 한다.

그럼 점원이 중간에 계속 바뀌는 경우에는 어떻게 해야할까?

```text
<점원이 중간에 계속 바뀌는 경우>

고객: 이 노트북 얼마인가요?
점원A : 100만원 입니다.

고객: 노트북 2개 구매하겠습니다.
점원B: 노트북 2개는 200만원입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠어요??

고객: 노트북 2개를 신용카드로 구매하겠습니다.
점원C: 노트북 2개 200만원 신용카드로 결제 완료되었습니다.
```

위와 같은 예시를 통해 Stateful 과 Stateless 의 차이점을 보면,

- *Stateful: 중간에 다른 점원으로 변경되면 안된다. 만약 다른 점원으로 바뀐다면 고객에 대한 정보를 다른 점원에게 미리 알려줘야 한다.*
  

- *Stateless: 중간에 다른 점원으로 바뀌어도 상관없다.*
    - *갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.*
    

- *즉, Stateless 의 경우 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있고, 각 클라이언트에 대해 응답 서버가 계속해서 변경될 수 있으므로, 무한한 서버 증설이 가능하다.*


Stateless 가 HTTP 의 특성이지만, 모든 것을 무상태로 설계 할 수 있는 경우도 있고 아닌 경우도 있다.

예를 들어, 로그인이 필요 없는 단순한 서비스 화면이라면 무상태로 설계가 가능하다.

하지만 로그인이 필요한 화면의 경우 상태 유지가 필요할 것이다.

로그인한 사용자에 대해서 로그인 했다는 상태를 서버에서 유지해야 하는데, 

일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지하는 경우가 많다.

상태 유지의 경우 최소한만 사용할 수 있도록 설계하는 것이 좋다.

위의 예시에도 알 수 있었지만, 고객에 대응하는 점원이 계속해서 변경 되듯이 HTTP 는 한 요청에 대해서 연결을 유지하지 않는다. 

**비 연결성(connectionless)** 의 특징을 갖는다.

연결을 유지하는 모델의 경우 서로 다른 클라이언트가 요청을 할 때마다 서버에서 연결을 유지해야 하고,

연결을 유지하기 위해서 서버 자원을 계속해서 소모해야 한다.

하지만 연결을 유지하지 않는 모델의 경우 클라이언트의 요청에 대해서 응답을 함과 동시에 연결을 종료한다.

이러한 모델은 서버 자원을 매우 효율적으로 사용할 수 있다.

1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다.

대표적인 예로 웹 브라우저에서 무언가를 검색할 때 사용자는 계속해서 검색 버튼을 누르지 않는다.

비 연결성 모델은 이렇듯 장점도 있지만, 그에 따르는 단점도 있다.

- *TCP/IP 연결을 매번 요청이 올 때마다 새로 맺어야 한다.*

  
- *웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등의 수 많은 자원이 함께 다운로드 되어야 하는 상황들이 발생한다.*

지금은 HTTP 지속 연결(Persistent Connections) 로 문제를 해결하였고, HTTP/2, HTTP/3 에서 더 많은 최적화가 이루어 지고 있다.

HTTP 초기에는 HTML 과 자바스크립트, 이미지를 응답해줘야 한다면, 연결, 응답, 종료에 각각 0.1초씩 소요된다는 가정하에

- *연결 > HTML 응답 > 종료: 0.3초*

- *연결 > 자바스크립트 응답 > 종료: 0.3초*

- *연결 > 이미지 응답 > 종료: 0.3초*

총 0.9초가 소요 되었다.

HTTP 지속 연결(Persistent Connections) 를 사용하면,

- *연결: 0.1초*

- *HTML 응답: 0.1초*

- *자바스크립트 응답: 0.1초*

- *이미지 응답: 0.1초*

- *종료: 0.1초*

총 0.5초로 연결, 종료에 낭비되는 시간들을 막을 수 있다.






  




















