# HTTP 기본

## HTTP 

HTTP 는 Hyper Text Transfer Protocol 을 말한다.

*HTTP 메시지에는 모든 것을 전송할 수 있다.*

- *HTML, TEXT*
- *이미지, 음성, 영상, 파일*
- *JSON, XML*
- *...*

거의 모든 형태의 데이터의 전송이 가능하다.

보통 클라이언트 - 서버 구조를 띄고 있지만, 서버 - 서버 간에도 데이터를 주고 받을 때 대부분 HTTP 를 사용한다.

### HTTP 역사

- *HTTP/0.9 (1991년): GET 메서드만 지원, HTTP 헤더 X*
- *HTTP/1.0 (1996년): 메서드, 헤더 추가*
- *HTTP/1.1 (1997년): 현재 가장 많이 사용하고 있는 버전*
  - *RFC2068(1997) > RFC2616(1999) > **RFC7230~7235 (2014)***
- *HTTP/2 (2015년): 성능 개선*
- *HTTP/3 진행 중: TCP 대신에 UDP 사용하여 성능 개선*

### 기반 프로토콜
- *TCP: HTTP/1.1, HTTP/2*


- *UDP: HTTP/3*


- *현재 HTTP/1.1 주로 사용하고 있고, HTTP/2, HTTP/3 도 점점 증가*

### HTTP 특징

HTTP 특징을 살펴보면,

**클라이언트 서버 구조**를 띄고 있다.

- *Request, Response 구조*


- *클라이언트는 서버에 요청을 보내고, 응답을 대기하고,*


- *서버가 요청에 대한 결과를 만들어서 응답을 보낸다.*

그 다음 특징으로는,

**무상태 프로토콜** 이라는 점이다. 스테이스리스(Stateless) 라고도 표현하는데,

- *서버가 클라이언트의 상태를 보존하지 않는다*


- *장점으로는 서버 확장성이 높다*


- *단점으로는 클라이언트가 추가 데이터 전송 시 추가 데이터만 전송이 불가능 하다*

상태 유지(Stateful) 과 무상태(Stateless) 의 차이를 알아보자.

한 고객이 노트북을 구매하려는 상황을 예로 들어보자.

```text
<일반적인 점원이 한 명인 경우>

고객: 이 노트북 얼마인가요?
점원: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원: 200만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠어요?

고객: 신용카드로 구매하겠습니다.
점원: 200만원 결제 완료되었습니다.

<점원이 중간에 계속 바뀌는 경우>

고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원B: ?? 어떤 제품을 2개 구매하시겠어요??

고객: 신용카드로 구매하겠습니다.
점원C: ??? 어떤 제품을 몇 개 신용카드로 구매하시겠다는건가요??
```

위의 예를 봤을 때,

일반적인 점원이 한 명인 경우에는 고객이 사려는 것이 노트북이고 노트북을 2개 산다는 것을 알기 때문에 신용카드 결제까지 자연스럽게 이어질 수 있었다.

하지만 점원이 중간에 바뀌는 경우에는 고객이 2개를 구매한다고 하거나 신용카드로 구매한다고 하였을 때,

어떤 제품을 사려는지, 어떤 제품을 2개 사려는지에 대해 알지 못하기 때문에 고객이 요구하는 것을 제대로 이행하지 못했다.

이와 같이 일반적인 점원이 한 명이 고객이 새로운 정보를 전달해도 이전의 정보를 기억하고 있는 것을 **Stateful** 하다고 한다.

그리고 점원이 중간에 바뀌어서 이전의 정보를 기억하고 있지 않는 것을 **Stateless** 라고 한다.

그럼 점원이 중간에 계속 바뀌는 경우에는 어떻게 해야할까?

```text
<점원이 중간에 계속 바뀌는 경우>

고객: 이 노트북 얼마인가요?
점원A : 100만원 입니다.

고객: 노트북 2개 구매하겠습니다.
점원B: 노트북 2개는 200만원입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠어요??

고객: 노트북 2개를 신용카드로 구매하겠습니다.
점원C: 노트북 2개 200만원 신용카드로 결제 완료되었습니다.
```

위와 같은 예시를 통해 Stateful 과 Stateless 의 차이점을 보면,

- *Stateful: 중간에 다른 점원으로 변경되면 안된다. 만약 다른 점원으로 바뀐다면 고객에 대한 정보를 다른 점원에게 미리 알려줘야 한다.*


- *Stateless: 중간에 다른 점원으로 바뀌어도 상관없다.*
  - *갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.*


- *즉, Stateless 의 경우 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있고, 각 클라이언트에 대해 응답 서버가 계속해서 변경될 수 있으므로, 무한한 서버 증설이 가능하다.*


Stateless 가 HTTP 의 특성이지만, 모든 것을 무상태로 설계 할 수 있는 경우도 있고 아닌 경우도 있다.

예를 들어, 로그인이 필요 없는 단순한 서비스 화면이라면 무상태로 설계가 가능하다.

하지만 로그인이 필요한 화면의 경우 상태 유지가 필요할 것이다.

로그인한 사용자에 대해서 로그인 했다는 상태를 서버에서 유지해야 하는데,

일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지하는 경우가 많다.

상태 유지의 경우 최소한만 사용할 수 있도록 설계하는 것이 좋다.

위의 예시에도 알 수 있었지만, 고객에 대응하는 점원이 계속해서 변경 되듯이 HTTP 는 한 요청에 대해서 연결을 유지하지 않는다.

**비 연결성(connectionless)** 의 특징을 갖는다.

연결을 유지하는 모델의 경우 서로 다른 클라이언트가 요청을 할 때마다 서버에서 연결을 유지해야 하고,

연결을 유지하기 위해서 서버 자원을 계속해서 소모해야 한다.

하지만 연결을 유지하지 않는 모델의 경우 클라이언트의 요청에 대해서 응답을 함과 동시에 연결을 종료한다.

이러한 모델은 서버 자원을 매우 효율적으로 사용할 수 있다.

1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다.

대표적인 예로 웹 브라우저에서 무언가를 검색할 때 사용자는 계속해서 검색 버튼을 누르지 않는다.

비 연결성 모델은 이렇듯 장점도 있지만, 그에 따르는 단점도 있다.

- *TCP/IP 연결을 매번 요청이 올 때마다 새로 맺어야 한다.*


- *웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등의 수 많은 자원이 함께 다운로드 되어야 하는 상황들이 발생한다.*

지금은 HTTP 지속 연결(Persistent Connections) 로 문제를 해결하였고, HTTP/2, HTTP/3 에서 더 많은 최적화가 이루어 지고 있다.

HTTP 초기에는 HTML 과 자바스크립트, 이미지를 응답해줘야 한다면, 연결, 응답, 종료에 각각 0.1초씩 소요된다는 가정하에

- *연결 > HTML 응답 > 종료: 0.3초*

- *연결 > 자바스크립트 응답 > 종료: 0.3초*

- *연결 > 이미지 응답 > 종료: 0.3초*

총 0.9초가 소요 되었다.

HTTP 지속 연결(Persistent Connections) 를 사용하면,

- *연결: 0.1초*

- *HTML 응답: 0.1초*

- *자바스크립트 응답: 0.1초*

- *이미지 응답: 0.1초*

- *종료: 0.1초*

총 0.5초로 연결, 종료에 낭비되는 시간들을 막을 수 있다.


## HTTP 메시지

HTTP 메시지에 거의 모든 형태의 데이터가 전송 가능하다.

- *HTML, TEXT, 이미지, 음성, 영상, 파일, JSON, XML, ...*

### HTTP 메시지 구조

![HTTP 메시지 구조](images/http-message-structure.png)

공식 스펙 ([https://tools.ietf.org/html/rfc7230#section-3](https://tools.ietf.org/html/rfc7230#section-3))

```text
HTTP-message  = start-line
                * ( header-field CRLF )
                CRLF
                [ message-body ]
```

### 시작 라인

<span style="font-size: 20px;">
  요청 메시지 (start-line = <b>request-line</b> / status-line) 
</span><br>
<span style="font-size: 18px; font-weight: lighter;">
  request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
</span>

- method: HTTP 메서드
    - *GET, POST, PUT, DELETE, ...*
    - *서버가 수행해야 할 동작 지정*


- request-target: 요청 대상
    - *절대경로[?쿼리]: absolute-path[?query]*


- HTTP version
    - *HTTP/1.1, HTTP/2, HTTP/3, ...*

<span style="font-size: 20px;">
  응답 메시지 (start-line = request-line / <b>status-line</b>) 
</span><br>
<span style="font-size: 18px; font-weight: lighter;">
  status-line = HTTP-version SP status-code SP reason-phrase CRLF(엔터)
</span>

- HTTP version
    - *HTTP/1.1, HTTP/2, HTTP/3, ...*


- status-code: HTTP 상태 코드
    - *200: 성공*
    - *400: 클라이언트 요청 오류*
    - *500: 서버 내부 오류*


- reason-phrase: 이유 문구

### HTTP 헤더

<span style="font-size: 18px;">
  header-field = field-name":" OWS field-value OWS(OWS: 띄어쓰기 허용, field-name: 대소문자 구분 없음)
</span>

- HTTP 전송에 필요한 모든 부가정보
  - *메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보, ...*
 
 
- 표준 헤더가 너무 많다. 
  - *[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)*
 
 
- 필요시 임의의 헤더 추가 가능


### HTTP 메시지 바디

- 실제 전송할 데이터
    - *HTML 문서, 이미지, 영상, JSON 등의 byte 로 표현할 수 있는 모든 데이터 전송 가능*
  
## 확장 가능

- HTTP 는 단순하다
- HTTP 메시지도 매우 단순하다.
- 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술



  



