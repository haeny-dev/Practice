# HTTP 헤더 - 캐시와 조건부 요청

## 캐시 기본 동작

웹 브라우저에서 이미지를 검색하였을 때 웹 브라우저는 이미지를 띄워주기 위해서 서버로부터 이미지를 다운받는다.

보통 이미지의 경우 text, html, json 등과 같은 문서보다 크기가 매우 커서 다운로드 받는데 더 많은 시간이 소요된다.

만약, 너무나도 고해상도라서 이미지의 크기가 커서 로딩되는데 시간이 오래걸리는 이미지를 검색해서 보고있다고 가정하자.

보고있던 도중에 실수로 새로고침 버튼을 눌렀는데, 이때 캐시가 없다면 웹 브라우저는 서버에 이미지를 요청하고, 또 다시 다운로드 받기 시작할 것이다.

그럼 사용자인 클라이언트는 이 초고해상도의 이미지를 보기위해서 다운로드 되는 동안의 시간을 소비해야 하는 것이다.

이렇듯 사용자는 캐시가 없을 경우,

- *데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.*


- *인터넷 네트워크는 매우 느리고 비싸다.*


- *브라우저 로딩 속도가 느리다.*


- *즉, 느린 사용자 경험을 하게 된다.*

그럼 캐시가 있고, 적용되었을 경우에는 어떻게 될까?

위와 마찬가지로 클라이언트가 초고해상도 이미지를 보기 위해서 서버에 이미지를 요청했다.

이번에는 서버에서 돌아오는 응답의 헤더에 `cache-control: max-age=60` 이라는 헤더값이 추가되어 반환되었다.

클라이언트는 모르겠지만 이 과정에서 클라이언트의 웹 브라우저는 응답 헤더의 항목을 보고 브라우저 캐시에 응답 결과와 함께 60초 유효하다는 정보를 저장한다.

이미지를 보기 시작한지 1분도 채 지나지 않았는데 사용자가 이미지를 보고있던 도중 새로고침 버튼을 누르게 되었다.

그런데 이번에는 이미지 로딩을 기다리는 시간 없이 이미지가 바로 나타났다.

어떻게 된 일인가 하면은 앞서 서버의 응답 결과를 브라우저는 브라우저 캐시에 저장을 해두었고,

사용자가 캐시가 유효한 60초 이내에 다시 같은 요청을 하였기 때문에 브라우저는 또 다시 서버에 요청하는 것이 아닌 브라우저 캐시에 있는 응답 결과를 바로 보여준 것이다.

이렇게 캐시가 적용이 된다면,

- *캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.*


- *비싼 네트워크 사용량을 줄일 수 있다.*


- *브라우저 로딩 속도가 매우 빠르다.*


- *결론적으로 빠른 사용자 경험을 할 수 있다.*

하지만 캐시는 이전에 받아온 결과를 응답해주는 것이고 또한 유효기간이 있는데, 유효기간이 지난 후에 요청하면 똑같은거 아닐까?

앞에서와 마찬가지로 고해상도 이미지를 서버에 요청하여 응답헤더에 `cache-control: max-age=60` 를 응답받아 브라우저 캐시에 60초 유효하다는 정보를 저장하였고,

이번엔 사용자가 유효 시간인 60초가 지난 후에 새로고침 버튼을 눌렀더니, 웹 브라우저는 브라우저 캐시에 유효시간이 지난 것을 확인하고,

다시 서버에 이미지를 요청하여 다운로드 받기 시작하였다.

이렇듯 기본적으로 캐시의 시간이 초과되는 경우

- *서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.*


- *이때 다시 네트워크 다운로드가 발생한다.*

## 검증 헤더와 조건부 요청1

캐시의 유효 시간이 초과하여 서버에 다시 요청을 하면 두 가지 상황이 나타난다.

1. *서버에서 기존 데이터를 변경함*


2. *서버에서 기존 데이터를 변경하지 않음*

이 두 가지 상황 중에 1번의 경우 다시 데이터를 다운받아야 하는 것이 명확하지만, 2번의 경우 굳이 다시 다운받지 않아도 브라우저 캐시에 저장되어있는 것을 재사용해도 되지 않나? 라는 생각을 할 수 있다.

단, 브라우저 캐시에는 이미 유효시간이 초과했기 때문에 사용자는 머리로 생각했을 때 가능하다고 생각하지만, 웹 브라우저 입장에서는 브라우저 캐시에서 다시 꺼내 쓸 명분이 부족하다 이거야!

그럼 이제 그 명분을 어떻게 만들수 있을까?

클라이언트인 사용자는 명분을 만들기 위해 서버에 찾아가서 불만을 얘기한다.

캐시 유효시간은 60초로 짧고, 60초 지났다고 해서 이미지가 무조건 바뀌는 것도 아닌데 굳이 바뀐거 아니면, 브라우저 캐시에 있는거 다시 쓸수 있게 해주면 안되겠냐 아니면 캐시 유효시간을 늘려주던가! 라고 요청을
한다.

서버 측에서는 캐시 유효시간을 늘러주는 것은 어렵다고 한다.

하지만 캐시를 더 효율적으로 사용할 수 있도록 조치하겠다는 답변을 듣고 사용자는 집으로 돌아갔다.

얼마 뒤에 사용자는 또 다시 고해상도 이미지를 보고 있었고, 캐시 유효시간이 한참 지난 시간 후에 새로고침을 하였는데, 빠른 속도로 이미지가 제공되는 것이다.

어떻게 된 것일까?

서버는 앞서 발생한 사용자의 불만을 해결하기 위해 캐시를 더 효율적으로 사용할 수 있도록 고민하였고, 그 해결 방안으로 응답헤더에 검증할 수 있는 정보를 추가하기로 했다.

최초 클라이언트가 서버에 이미지를 요청하였을 때 서버에서는 응답 헤더에 `cache-control: max-age=60` 와 추가로   
`Last-Modified: 2022년 2월 19일 09:00:00` 이라는 정보를 반환해 준다.

클라이언트의 웹 브라우저는 브라우저에 캐시에 응답 결과를 저장하면서 유효 시간은 60초고, 데이터의 최종 수정일은  
"2022년 2월 19일 09:00:00" 이야라고 새로운 정보를 저장을 하게 된다.

이후 클라이언트가 유효 시간이 지난 후 새로고침을 하게 되었을 때, 클라이언트의 웹 브라우저는 캐시의 유효 시간이 지난 것을 확인하고, 다시 서버에 요청을 하는데 이때 요청
헤더에 `if-modified-since: 2022년 2월 19일 09:00:00` 을 추가해서 전달했다.

이 요청을 받은 서버는 요청 헤더의 `if-modified-since: 2022년 2월 19일 09:00:00` 값을 확인하고, 해당 리소스의 최종 수정일을 확인하였는데, 요청으로부터 받은 최종 수정일과 비교하였을
때 아직 데이터가 수정되지 않았음을 확인할 수 있었다.

서버는 응답의 상태코드로 304 Not Modified 를 하고, 다시 한번 `cache-control: max-age=60`,  
`Last-Modified: 2022년 02월 19일 09:00:00` 이라는 값을 헤더에 추가하여 반환하였다.

그런데 응답을 자세히 살펴보니 HTTP Body 가 없는 상태로 전달된 것이다.

즉, 서버는 사용자로부터 이 데이터가 변경되었냐는 질문을 받았고 데이터가 변경되지 않음을 확인한 후 변경되지 않았다는 사실만 전달한 것이다.

이러한 사실만을 전달받은 클라이언트의 웹 브라우저는 응답의 상태코드를 확인하고, 브라우저 캐시에 유효시간을 다시 갱신하고 해당 결과로 리다이렉션 하여 사용자에게 이미지를 보여주었다.

클라이언트와 서버는 이러한 검증 헤더와 조건부 요청을 통해서 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면,

- *304 Not Modified 상태코드와 헤더 메타 정보만 응답*


- *클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신*


- *클라이언트는 캐시에 저장되어 있는 데이터 재활용*


- *결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드*


- *매우 실용적인 해결책*

## 검증 헤더와 조건부 요청2

검증 헤더

- *캐시 데이터와 서버 데이터가 같은지 검증하는 데이터*
- *Last-Modified, ETag*

조건부 요청 헤더

- *검증 헤더로 조건에 따른 분기*
- *If-Modified-Since: Last-Modified 사용*
- *If-None-Match: ETag 사용*
- *조건이 만족하면 200 OK*
- *조건이 만족하지 않으면 304 Not Modified*

### Last-Modified, If-Modified-Since 단점

If-Modified-Since → 이후에 데이터가 수정되었니? 라는 질문에

**데이터 미변경 시**

- *캐시( 2022년 2월 19일 09:00:00 ) vs 서버( 2022년 2월 19일 09:00:00 )*
- *304 Not Modified, 헤더 데이터만 전송*
- *헤더 데이터 용량*

**데이터 변경 시**

- *캐시( 2022년 2월 19일 09:00:00 ) vs 서버( 2022년 2월 19일 10:00:00 )*
- *200 OK, 모든 데이터 전송*
- *헤더 데이터 + 바디 데이터 용량*

**단점**

- *1초 미만 단위로 캐시 조정이 불가능*
  

- *날짜 기반의 로직 사용*
  

- *데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우*
  

- *서버에서 별도의 캐시 로직을 관리하고 싶은 경우*
    - *에) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우*

### ETag, If-None-Match

ETag(Entity Tag)

- *캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.*
    - *예) ETag: "v1.0", ETag: "a2jikdekl"*


- *데이터가 변경되면 이 이름을 바꾸어서 변경함(hash를 다시 생성)*
    - *예) ETag: "aaa" → "bbb"*
  

- *단순하게 ETag 만 보내서 같으면 유지, 다르면 다시 받기*


- ***캐시 제어 로직을 서버에서 완전히 관리한다.***


- *클라이언트는 단순히 이 값을 서버에 제공하고 클라이언트는 캐시 메커니즘을 모른다.*

## 캐시와 조건부 요청 헤더

### 캐시 제어 헤더 - Cache-Control
캐시 지시어(directives)

- *Cache-Control: max-age → 캐시 유효시간, 초 단위*


- *Cache-Control: no-cache → 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용*


- *Cache-Control: no-store → 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)*

### 캐시 제어 헤더 - Pragma
캐시 제어(하위 호환)

- *Pragma: no-cache*


- *HTTP 1.0 하위 호환*

### 캐시 제어 헤더 - Expires
캐시 만료일 지정(하위 호환)

- *expires: Mon, 01 Jan 1990 00:00:00 GMT*


- *캐시 만료일을 정확한 날짜로 지정*


- *HTTP 1.0 부터 사용*


- *지금은 더 유연한 Cache-Control: max-age 권장하고 Expires 와 같이 사용하면 Expires 무시*


### 검증헤더와 조건부 요청 헤더

**검증 헤더(Validator)**

- *ETag: "v1.0"*
  

- *Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT*

**조건부 요청 헤더**

- *If-Match, If-None-Match: ETag 값 사용*


- *If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용*

## 프록시 캐시

한국에 있는 클라이언트가 미국에 있는 서버에 요청을 보낼 경우 인터넷망을 통해서 요청을 전달하겠지만, 물리적으로도 데이터가 전달되는 과정이 있다.

실질적으로 한국과 미국 사이에 매우 큰 거리의 차이가 있어서 요청과 응답에는 더 많은 시간이 소요될 수 있다.

이러한 문제를 극복하기 위해서 한국 어딘가에 프록시 캐시 서버를 설치하고, 프록시 캐시 서버만이 미국에 있는 원 서버에 접근을 하며,

한국에 있는 클라이언트는 프록시 캐시 서버에 접근하여 응답을 받는다.

프록시 캐시는 미국에 있는 origin 서버로부터 받은 정보를 캐시로 저장하였다가 클라이언트에게 제공하여 public 캐시라고 하고,

클라이언트가 프록시 서버로부터 응답받은 정보를 브라우저 캐시에 저장한 것을 private 캐시라 한다.

### Cache-Control
캐시 지시어(directives) - 기타

- *Cache-Control: public → 응답이 public 캐시에 저장되어도 됨*
    

- *Cache-Control: private → 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)*


- *Cache-Control: s-maxage → 프록시 캐시에만 적용되는 max-age*


- *Age: 60 → origin 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)*

## 캐시 무효화

### Cache-Control
캐시 지시어(directives) - 확실한 캐시 무효화

- *Cache-Control: no-cache*
    - *데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용*
    - *원 서버 접근할 수 없는 경우 캐시 서버 설정에 따라서 캐시 데이터를 반환할 수 있음 - Error or 200 OK*

- *Cache-Control: no-store*
    - *데이터에 민감한 정보가 있으므로 저장하면 안됨*

- *Cache-Control: must-revalidate*
    - *캐시 만료 후 최초 조회시 원 서버에 검증해야 함*
    - *원 서버 접근 실패 시 반드시 오류가 발생해야 함 - 504(Gateway Timeout)*
    - *must-revalidate 는 캐시 유효 시간이라면 캐시를 사용함*

- *Pragma: no-cache → HTTP 1.0 하위 호환*
