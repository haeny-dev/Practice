# Chapter01. 노드 시작하기

## 📌 1.1 핵심 개념 이해하기

> Node.js 는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임입니다.

- 서버라는 말이 없는 이유는 노드가 서버만 실행할 수 있는 것이 아니기 때문입니다.

### ➕ 1.1.1 서버

- 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다.
- 클라이언트란 요청을 보내는 주체로 브라우저일 수도 있고, 데스크톱 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있습니다.

- 예를 들어, 모바일 앱을 설치하는 경우

  - 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누르면 => 요청
  - 내려받기 => 응답
  - 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있다.
  - 그 어딘가가 구글과 애플의 서버이고, 플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것입니다.

- 노드는 자바스크립트 프로그램이 서버로서 가능하기 위한 도구를 제공하으로 서버 역할을 수행할 수 있습니다.

### ➕ 1.1.2 자바스크립트 런타임

- 노드는 자바스크립트 런타임입니다.
- 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻합니다.
- 따라서, 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있습니다.
- 기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었습니다. 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있습니다.

- 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하였고, V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐습니다. 구글은 또한 오픈소스로 코드를 공개하였고, 속도 문제가 해결되자 라이언 달은 2009년 V8 엔진 기반의 노드 프로젝트를 시작하였습니다.

- 노드의 내부 구조

  ```
  [ Node.js Core Library ]
    [ Node.js Bindings ]
    [ V8 ]    [ libuv ]
      ||         ||
    오픈 소스     비동기 I/O

    [ 자바스크립트 엔진 ]
  ```

  - 노드는 V8 과 더불어 libuv라는 라이브러리를 사용합니다.
  - V8과 libuv는 C와 C++로 구현되어 있습니다.
  - libuv 라이브러리는 노드의 특성인 이벤트기반, 논 블로킹 I/O 모델을 구현하고 있습니다.

### ➕ 1.1.3 이벤트 기반

> 이벤트 기반(event-driven) 이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미합니다.

- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 합니다. 이를 이벤트 리스너(event listener) 에 콜백(callback) 함수를 등록한다고 표현합니다.

  ```
  [시스템]  =========>  [이벤트 리스너]
          2.이벤트 발생   1.이벤트 리스너에
                          콜백 함수 등록
          <=========
        3.등록된 콜백 함수 호출
  ```

- 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.
- 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견했다면 호출한 함수를 호출 스택(call stack)에 넣습니다.

  ```javascript
  function first() {
    second()
    console.log('첫번째')
  }
  function second() {
    third()
    console.log('두번째')
  }
  function third() {
    console.log('세번째')
  }
  first()
  ```

  ```
  ▲▲▲▲▲▲▲  [ third() ]  ▼▼▼▼▼▼▼▼
  이 순서로  [ second() ] 이 순서로
    쌓이고    [ first() ]  실행됨
          [ anonymous ]
  ```

  - anonymous 함수는 처음 실행 시의 전역 컨텍스트(global context) 를 의미합니다.
  - 컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미합니다.

- **이벤트 루프**
  - 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop) 라고 부릅니다.
- **백그라운드**
  - setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳입니다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 됩니다. 여러 작업이 동시에 실행될 수 있습니다.
- **태스크 큐**
  - 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냅니다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부릅니다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 합니다.

```
1. 호출 스택에 쌓임
2. setTimeout 실행 시 콜백 run은 백그라운드로 보냄
3. 백그라운드에서 3초 후 태스크 큐로 보냄

  <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

[setTimeout()]       [타이머run 3초]            [run]
 [anonymous]

4. 호출 스택 실행이 끝나 비워지면
5. 이벤트 루프가 태스크 큐의 콜백을 호출 스택으로 올림

  <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

                                              [run]

6. run이 호출 스택에서 실행되고 비워짐
7. 이벤트 루프는 태스크 큐에 콜백이 들어올 때까지 대기

  <호출 스택>   ====>    <백그라운드>    ====>   <태스크 큐>

   [run]

만약, 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수 있습니다. 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문입니다. 이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유입니다.
```

## 1.2 서버로서의 노드

## 1.3 서버 외의 노드

## 1.4 개발 환경 설정하기

## 1.5 함께 보면 좋은 자료
